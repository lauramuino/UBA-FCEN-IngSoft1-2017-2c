Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'AD 11/12/2017 16:27'!hasStreetName: aStreetName	^ streetName = aStreetName.! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !TestCase subclass: #CustomerImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!Object subclass: #CustomerImporter	instanceVariableNames: 'line input record newCustomer system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImporter methodsFor: 'accessing' stamp: 'AD 11/12/2017 16:55'!isAddressRecord	^ (record at: 1) = 'A'.! !!CustomerImporter methodsFor: 'accessing' stamp: 'lm 11/9/2017 20:11'!createRecordFromLine	record := line substrings: {$,}! !!CustomerImporter methodsFor: 'accessing' stamp: 'AD 11/12/2017 16:54'!parseData	self isCustomerRecord		ifTrue: [ ^ self parseCustomer ].   self isAddressRecord		ifTrue: [ ^ self parseAddress ].			self error: CustomerImporter errorInvalidTypeOfInput.! !!CustomerImporter methodsFor: 'accessing' stamp: 'AD 11/12/2017 16:55'!isCustomerRecord	^ (record at: 1) = 'C'.! !!CustomerImporter methodsFor: 'accessing' stamp: 'lm 11/13/2017 20:51'!parseCustomer	(self recordSizeEquals: 5)		ifFalse: [ ^ self error: CustomerImporter errorInvalidCustomer ].	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	system add: newCustomer.! !!CustomerImporter methodsFor: 'accessing' stamp: 'AD 11/12/2017 16:57'!recordSizeEquals: aSize	^ record size = aSize! !!CustomerImporter methodsFor: 'accessing' stamp: 'lm 11/9/2017 20:44'!importFrom: inputStream	( inputStream isEmpty ) ifTrue: [ ^ self error: CustomerImporter errorEmptyInputData ].	input := inputStream.	[ self hasNextLine ]		whileTrue: [ 			self createRecordFromLine.			self parseData 			].! !!CustomerImporter methodsFor: 'accessing' stamp: 'lm 11/13/2017 20:49'!with: aSystem		system := aSystem ! !!CustomerImporter methodsFor: 'accessing' stamp: 'AD 11/12/2017 16:58'!parseAddress	| newAddress |	(self recordSizeEquals: 6)		ifFalse: [ ^ self error: CustomerImporter errorInvalidAddress ].	( newCustomer isNil )		ifTrue: [ ^ self				error: CustomerImporter errorCannotParseAddressWithouthCustomer ].	newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newCustomer addAddress: newAddress! !!CustomerImporter methodsFor: 'testing' stamp: 'lm 11/9/2017 19:28'!hasNextLine	line := input nextLine.	^ line notNil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'lm 11/9/2017 20:18'!with: aSession		^ self new with: aSession.! !!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/9/2017 20:48'!errorCannotParseAddressWithouthCustomer	^ 'No se puede parsear una direccion sin un cliente'! !!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/9/2017 20:40'!errorEmptyInputData	^ 'El input de entrada es vacio.'! !!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/9/2017 20:53'!errorInvalidTypeOfInput	^ 'El tipo del input es invalido.'! !!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/9/2017 21:04'!errorInvalidAddress	^ 'El input del address es invalido'! !!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/9/2017 20:58'!errorInvalidCustomer	^ 'El input del customer es invalido'! !TestCase subclass: #CustomerImporterTest	instanceVariableNames: 'customerImporter system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImporterTest methodsFor: 'tearDown' stamp: 'lm 11/13/2017 20:41'!tearDown	system commit.	system close! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'AD 11/12/2017 16:17'!assertValidCustomer: aCustomer withFirstName: aFirstName withLastName: aLastName withIdentificationNumber: anIDNumber withIdentificationType: aType	self assert: aCustomer firstName = aFirstName.	self assert: aCustomer lastName = aLastName.	self assert: aCustomer identificationNumber = anIDNumber.	self assert: aCustomer identificationType = aType.! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'ad 11/18/2017 16:59'!assertCustomersSize: aSize	self assert: system allEntitiesSize equals: aSize! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'ad 11/18/2017 17:05'!assertJuanPerezImportedCorrectly	| customerJuanPerez |		customerJuanPerez := self entityIdentifiedAs: '23-25666777-9' ofType: 'C'.		self 		assertValidCustomer: customerJuanPerez		withFirstName: 'Juan'		withLastName: 'Perez'		withIdentificationNumber: '23-25666777-9'		withIdentificationType: 'C'.			self		assertValidAddress: ( customerJuanPerez addressWithStreetName: 'Alem' )		withStreetNumber: 1122		withStreetName: 'Alem'		withProvince: 'CABA'		withTown: 'CABA'		withZipCode: 1001.! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'ad 11/18/2017 17:05'!assertPepeSanchezImportedCorrectly	| customerPepeSanchez |	customerPepeSanchez := self entityIdentifiedAs: '22333444' ofType: 'D'.		self		assertValidCustomer: customerPepeSanchez		withFirstName: 'Pepe'		withLastName: 'Sanchez'		withIdentificationNumber: '22333444'		withIdentificationType: 'D'.			self		assertValidAddress: ( customerPepeSanchez addressWithStreetName: 'San Martin' )		withStreetNumber: 3322		withStreetName: 'San Martin'		withProvince: 'BsAs'		withTown: 'Olivos'		withZipCode: 1636.			self		assertValidAddress: ( customerPepeSanchez addressWithStreetName: 'Maipu' )		withStreetNumber: 888		withStreetName: 'Maipu'		withProvince: 'Buenos Aires'		withTown: 'Florida'		withZipCode: 1122.! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'AD 11/12/2017 16:16'!assertValidAddress: anAddress withStreetNumber: aStreetNumber withStreetName: aStreetName withProvince: aProvince withTown: aTown withZipCode: aZipCode	self assert: anAddress streetNumber = aStreetNumber.	self assert: anAddress streetName = aStreetName.	self assert: anAddress province = aProvince.	self assert: anAddress town = aTown.	self assert: anAddress zipCode = aZipCode! !!CustomerImporterTest methodsFor: 'initialization' stamp: 'ad 11/18/2017 16:54'!setUp	system := Environment current.	system start.	system beginTransaction.	customerImporter := CustomerImporter with: system! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 17:04'!test06noSePuedenParsearInputsDeDireccionesQueTenganMasDeSeisCamposDeEntrada	self		should:			[ self importCustomersFrom: self invalidCustomerWithSevenFieldsAddressTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidAddress.			self				assert:					(self entityIdentifiedAs: '22333444' ofType: 'D') addresses size 				equals: 0 ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 17:04'!test05noSePuedenParsearInputsDeDireccionesQueTenganMenosDeSeisCamposDeEntrada	self		should:			[ self importCustomersFrom: self invalidCustomerWithFiveFieldsAddressTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidAddress.			self				assert:					(self entityIdentifiedAs: '22333444' ofType: 'D') addresses size 				equals: 0 ].! !!CustomerImporterTest methodsFor: 'tests' stamp: 'AD 11/12/2017 16:59'!test03noSePuedenParsearTiposQueNoSeanClientesNiDirecciones	self		should:			[ self importCustomersFrom: self invalidInputType1TestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidTypeOfInput.			self assertCustomersSize: 0 ].self		should:			[ self importCustomersFrom: self invalidInputType2TestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidTypeOfInput.			self assertCustomersSize: 0 ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 17:05'!test07sePuedenImportarCustomersCorrectos	self importCustomersFrom: self validTestData.	self assertCustomersSize: 2.	self assertPepeSanchezImportedCorrectly.	self assertJuanPerezImportedCorrectly! !!CustomerImporterTest methodsFor: 'tests' stamp: 'lm 11/13/2017 20:54'!test04noSePuedenParsearInputsDeClientesQueNoTenganExactamenteCincoCamposDeEntrada	self		should: [ self				importCustomersFrom: self invalidCustomerWithThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidCustomer.			self assertCustomersSize: 0 ].	self		should:			[ self importCustomersFrom: self invalidCustomerWithSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidCustomer.			self assertCustomersSize: 0]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'AD 11/12/2017 16:48'!test01importarDeUnInputVacioGeneraUnaExcepcion	self		should: [ self importCustomersFrom: self emptyInput ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorEmptyInputData.			self assertCustomersSize: 0 ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'AD 11/12/2017 17:00'!test02noSePuedeImportarUnaDireccionSinUnCliente	self		should:			[ self importCustomersFrom: self invalidAddressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorCannotParseAddressWithouthCustomer.			self assertCustomersSize: 0 ]! !!CustomerImporterTest methodsFor: 'importing' stamp: 'lm 11/9/2017 20:32'!importCustomersFrom: input	customerImporter importFrom: input! !!CustomerImporterTest methodsFor: 'importing' stamp: 'lm 11/16/2017 20:03'!entityIdentifiedAs: anIdNumber ofType: aType	^ system entityIdentifiedAs: anIdNumber ofType: aType! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 16:59'!invalidInputType1TestData	^ ReadStream on: 'CC,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithFiveFieldsAddressTestData	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 16:48'!emptyInput	^ ReadStream on: ''! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithSevenFieldsAddressTestData	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAs, Blabla'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'lm 11/16/2017 19:02'!importSuppliersFrom: InputStream	self error: SuppliersImporter emptyInput .! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithThreeFieldsTestData	^ ReadStream on: 'C,Pepe,Sanchez'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 16:59'!invalidInputType2TestData	^ ReadStream on: 'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithSixFieldsTestData	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444,Blablabla'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'lm 11/9/2017 20:30'!validTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidAddressWithoutCustomerTestData	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'accessing' stamp: 'lm 11/13/2017 21:31'!isCurrent	self subclassResponsibility.! !!Environment class methodsFor: 'accessing' stamp: 'ad 11/18/2017 16:54'!system	self subclassResponsibility.! !!Environment class methodsFor: 'accessing' stamp: 'ad 11/18/2017 16:55'!current	( Environment subclasses )		detect: [ :anEnvironment | anEnvironment isCurrent ]		ifFound:  [ :currentEnvironment | ^currentEnvironment system ]! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'lm 11/13/2017 21:31'!isCurrent	^ ( IntegrationEnvironment isCurrent ) not.! !!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'ad 11/18/2017 17:18'!system	^ TransientSystem new.! !Object subclass: #ErpSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpSystem methodsFor: 'asserting' stamp: 'lm 11/16/2017 20:06'!allEntities
	self subclassResponsibility! !!ErpSystem methodsFor: 'asserting' stamp: 'ad 11/18/2017 16:57'!allEntitiesSize
	self subclassResponsibility! !!ErpSystem methodsFor: 'asserting' stamp: 'ad 11/18/2017 16:52'!entityIdentifiedAs: anIdNumber ofType: aType
	self subclassResponsibility! !!ErpSystem methodsFor: 'accessing' stamp: 'lm 11/13/2017 20:57'!add: newCustomer
	self subclassResponsibility! !!ErpSystem methodsFor: 'initialization' stamp: 'lm 11/13/2017 21:08'!beginTransaction! !!ErpSystem methodsFor: 'initialization' stamp: 'lm 11/13/2017 21:08'!start! !!ErpSystem methodsFor: 'tearDown' stamp: 'lm 11/13/2017 21:08'!close! !!ErpSystem methodsFor: 'tearDown' stamp: 'lm 11/13/2017 21:08'!commit! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'ad 11/18/2017 17:18'!system	^ PersistentCustomerSystem new.! !!IntegrationEnvironment class methodsFor: 'testing' stamp: 'ad 11/18/2017 18:00'!isCurrent	^false.! !Object subclass: #Party	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!Party subclass: #Customer	instanceVariableNames: 'firstName lastName identificationType addresses customerId id identificationNumber'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !!Customer methodsFor: 'identification' stamp: 'ad 11/17/2017 19:39'!id: anID	super id: anID.! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'ad 11/17/2017 19:39'!id	^ super id.! !!Customer methodsFor: 'identification' stamp: 'ad 11/18/2017 16:47'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'ad 11/18/2017 16:47'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:27'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'addresses' stamp: 'ad 11/17/2017 19:24'!addressWithStreetName: aStreetName	^  self addresses		detect: [ :anAddress | anAddress hasStreetName: aStreetName  ].! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:25'!addresses	^ addresses! !!Customer methodsFor: 'addresses' stamp: 'ad 11/18/2017 16:50'!isIdentifiedAs: anIDNumber withType: anIDType	^ identificationNumber = anIDNumber and: [ identificationType = anIDType  ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: 'test'!ErpSystem subclass: #PersistentSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentSystem methodsFor: 'tearDown' stamp: 'lm 11/16/2017 20:00'!close	session close! !!PersistentSystem methodsFor: 'tearDown' stamp: 'lm 11/16/2017 20:00'!commit	session commit! !!PersistentSystem methodsFor: 'accessing' stamp: 'lm 11/16/2017 20:07'!add: aEntity	session persist: aEntity! !!PersistentSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:00'!beginTransaction	session beginTransaction! !!PersistentSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:00'!start	session open! !!PersistentSystem methodsFor: 'initialization' stamp: 'ad 11/18/2017 16:57'!allEntitiesSize	^ ( self allEntities ) size.! !!PersistentSystem methodsFor: 'importing' stamp: 'ad 11/18/2017 17:01'!entityIdentifiedAs: anIdNumber ofType: aType	|entities|	entities := session		select: [ :aParty | aParty isIdentifiedAs: anIdNumber withType: aType ]		ofType: Customer.			( entities size ) ~= 1 ifTrue: [ self error: 'Hay más de una instancia del mismo customer' ].		^ entities anyOne.! !PersistentSystem subclass: #PersistentCustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentCustomerSystem methodsFor: 'asserting' stamp: 'lm 11/16/2017 20:06'!allEntities	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'ad 11/17/2017 19:30'!initialize	super initialize.	session := (DataBaseSession for: (Array with: self mapCustomers with: self mapAddress ))! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'ad 11/17/2017 19:29'!mapCustomers	^(ClassMapping						withDefaultTableNameFor: Customer						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #firstName)								with: (EmbededMapping withDefaultFieldNameFor: #lastName)								with: (EmbededMapping withDefaultFieldNameFor: #identificationType)								with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)								with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))).! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 19:32'!mapAddress	^ (ClassMapping						withDefaultTableNameFor: Address						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #streetName)								with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)								with: (EmbededMapping withDefaultFieldNameFor: #town)								with: (EmbededMapping withDefaultFieldNameFor: #zipCode)								with: (EmbededMapping withDefaultFieldNameFor: #province)))! !PersistentSystem subclass: #PersistentSupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentSupplierSystem methodsFor: 'asserting' stamp: 'lm 11/16/2017 20:06'!allEntities	^ session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:52'!initialize	super initialize.	session := (DataBaseSession for: (Array with: self mapSuppliers with: self mapAddress with: self mapCustomers )).! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:47'!mapCustomers	^(ClassMapping						withDefaultTableNameFor: Customer						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #firstName)								with: (EmbededMapping withDefaultFieldNameFor: #lastName)								with: (EmbededMapping withDefaultFieldNameFor: #identificationType)								with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)								with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))).! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:47'!mapAddress	^ (ClassMapping						withDefaultTableNameFor: Address						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #streetName)								with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)								with: (EmbededMapping withDefaultFieldNameFor: #town)								with: (EmbededMapping withDefaultFieldNameFor: #zipCode)								with: (EmbededMapping withDefaultFieldNameFor: #province)))! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:48'!mapSuppliers	^ (ClassMapping						withDefaultTableNameFor: Supplier						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #name)								with: (EmbededMapping withDefaultFieldNameFor: #identificationType)								with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)								with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)								with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)								))"Formato de importacion de Supplier:S,Supplier1,D,123 NC,Pepe,Sanchez,D,22333444 <-- new customerEC,D,5456774                            <-- existing customerA,San Martin,3322,Olivos,1636,BsAs A,Maipu,888,Florida,1122,Buenos Aires"! !Party subclass: #Supplier	instanceVariableNames: 'name customers identificationType addresses id identificationNumber'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Supplier methodsFor: 'addresses' stamp: 'ad 11/17/2017 19:24'!addAddress: anAddress 	addresses add: anAddress ! !!Supplier methodsFor: 'addresses' stamp: 'ad 11/17/2017 19:24'!addressWithStreetName: aStreetName	^  self addresses		detect: [ :anAddress | anAddress hasStreetName: aStreetName  ].! !!Supplier methodsFor: 'addresses' stamp: 'ad 11/17/2017 19:24'!addresses	^ addresses! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 20:42'!customers	^customers.! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 19:40'!name: aName	name := aName.! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 19:40'!name		^name.! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 20:41'!addCustomer: aCustomer	customers add: aCustomer.! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 19:46'!initialize	super initialize.	customers := OrderedCollection new.! !!Supplier methodsFor: 'initialization' stamp: 'ad 11/17/2017 19:41'!id	^id.! !!Supplier methodsFor: 'initialization' stamp: 'ad 11/17/2017 19:41'!id: anID	id := anID.! !!Supplier methodsFor: 'identification' stamp: 'ad 11/17/2017 19:25'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Supplier methodsFor: 'identification' stamp: 'ad 11/18/2017 16:47'!identificationNumber		^identificationNumber ! !!Supplier methodsFor: 'identification' stamp: 'ad 11/17/2017 19:25'!identificationType		^identificationType ! !!Supplier methodsFor: 'identification' stamp: 'ad 11/18/2017 16:47'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Supplier methodsFor: 'identification' stamp: 'ad 11/18/2017 17:15'!isIdentifiedAs: anIDNumber withType: anIDType	^ identificationNumber = anIDNumber and: [ identificationType = anIDType  ].! !Object subclass: #SupplierImporter	instanceVariableNames: 'line input record newSupplier system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/18/2017 18:06'!parseSupplier	(self recordSizeEquals: 4)		ifFalse: [ ^ self error: SupplierImporter errorInvalidSupplier ].	newSupplier := Supplier new.	newSupplier name: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.		system add: newSupplier.! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/18/2017 18:10'!parseExistentCustomer	| customer identificationType identificationNumber |	(self recordSizeEquals: 3)		ifFalse: [ ^ self error: SupplierImporter errorInvalidSupplier ].	( newSupplier isNil ) ifTrue: [ ^ self error: SupplierImporter errorCannotParseExistentCustomerWithouthSupplier  ].			identificationType := record second.	identificationNumber := record third.			customer := ( ( system allEntities ) select: [ :aEntity | ( aEntity isKindOf: Customer ) and: [ 			aEntity isIdentifiedAs: identificationNumber withType: identificationType 			 ] ] ) anyOne.		newSupplier addCustomer: customer.! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/18/2017 17:49'!parseAddress	| newAddress |	(self recordSizeEquals: 6)		ifFalse: [ ^ self error: SupplierImporter errorInvalidAddress ].	( newSupplier isNil ) ifTrue: [ ^ self error: SupplierImporter errorCannotParseAddressWithouthSupplier ].	newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newSupplier addAddress: newAddress! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/18/2017 18:10'!parseNewCustomer	| newCustomer |	(self recordSizeEquals: 5)		ifFalse: [ ^ self error: SupplierImporter errorInvalidSupplier ].	( newSupplier isNil ) ifTrue: [ ^ self error: SupplierImporter errorCannotParseNewCustomerWithouthSupplier  ].	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	newSupplier addCustomer: newCustomer.! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/18/2017 18:03'!parseData	self isSupplierRecord  		ifTrue: [ ^ self parseSupplier ].	self isNewCustomerRecord 		ifTrue: [ ^ self parseNewCustomer ].	self isExistentCustomerRecord 		ifTrue: [ ^ self parseExistentCustomer ].   self isAddressRecord		ifTrue: [ ^ self parseAddress ].			self error: SupplierImporter errorInvalidTypeOfInput.! !!SupplierImporter methodsFor: 'accessing' stamp: 'lm 11/16/2017 19:17'!createRecordFromLine	record := line substrings: {$,}! !!SupplierImporter methodsFor: 'testing' stamp: 'lm 11/16/2017 19:17'!hasNextLine	line := input nextLine.	^ line notNil.! !!SupplierImporter methodsFor: 'initialization' stamp: 'lm 11/16/2017 19:17'!isAddressRecord	^ (record at: 1) = 'A'.! !!SupplierImporter methodsFor: 'initialization' stamp: 'ad 11/18/2017 17:57'!isExistentCustomerRecord	^ (record at: 1) = 'EC'.! !!SupplierImporter methodsFor: 'initialization' stamp: 'ad 11/18/2017 17:58'!isSupplierRecord	^ (record at: 1) = 'S'.! !!SupplierImporter methodsFor: 'initialization' stamp: 'lm 11/16/2017 19:17'!with: aSystem		system := aSystem ! !!SupplierImporter methodsFor: 'initialization' stamp: 'ad 11/18/2017 17:54'!importFrom: inputStream	( inputStream isEmpty ) ifTrue: [ ^ self error: SupplierImporter errorEmptyInputData ].	input := inputStream.	[ self hasNextLine ]		whileTrue: [ 			self createRecordFromLine.			self parseData 			].! !!SupplierImporter methodsFor: 'initialization' stamp: 'lm 11/16/2017 19:42'!isNewCustomerRecord	^ (record at: 1) = 'NC'.! !!SupplierImporter methodsFor: 'initialization' stamp: 'lm 11/16/2017 19:17'!recordSizeEquals: aSize	^ record size = aSize! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'lm 11/16/2017 19:17'!with: aSession		^ self new with: aSession.! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/18/2017 17:49'!errorCannotParseAddressWithouthSupplier	^ 'No se puede parsear una direccion sin un supplier'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/18/2017 17:57'!errorCannotParseExistentCustomerWithouthSupplier	^ 'No se puede agregar un cliente ya existente sin un supplier'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/18/2017 17:54'!errorInvalidSupplier	^ 'El input del supplier es invalido'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/16/2017 19:17'!errorEmptyInputData	^ 'El input de entrada es vacio.'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/16/2017 19:17'!errorInvalidTypeOfInput	^ 'El tipo del input es invalido.'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/16/2017 19:17'!errorInvalidAddress	^ 'El input del address es invalido'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/18/2017 17:49'!errorCannotParseNewCustomerWithouthSupplier	^ 'No se puede parsear un nuevo cliente sin un supplier'! !TestCase subclass: #SuppliersImporterTest	instanceVariableNames: 'system supplierImporter'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SuppliersImporterTest methodsFor: 'setUp-tearDown' stamp: 'ad 11/18/2017 17:56'!setUp	system := TransientSystem new.	system start.	system beginTransaction.	supplierImporter := SupplierImporter with: system! !!SuppliersImporterTest methodsFor: 'importing' stamp: 'ad 11/18/2017 17:55'!importSuppliersFrom: inputStream	^ supplierImporter importFrom: inputStream.				! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/18/2017 17:19'!assertSuppliersSize: aSize	self assert: system allEntitiesSize equals: aSize! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:06'!invalidSupplierWithThreeFieldsTestData	^ReadStream on: 'S,Supplier1,D'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeSS	^ReadStream on: 'SS,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 17:56'!invalidExistentCustomerWithouthSupplierTestData	^ReadStream on: 'EC,D,5456774'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeECC	^ReadStream on: 'ECC,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:13'!invalidExistentCustomerWithTwoFieldsTestData	^ReadStream on: 'S,Supplier1,D,123EC,D'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:12'!invalidExistentCustomerWithFourFieldsTestData	^ReadStream on: 'S,Supplier1,D,123EC,D,123,bla'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 17:12'!invalidAddressWithouthSupplierTestData	^ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeAA	^ReadStream on: 'AA,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'lm 11/16/2017 19:08'!emptyInput	^ ReadStream on: ''! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeNCC	^ReadStream on: 'NCC,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:07'!invalidSupplierWithFiveFieldsTestData	^ReadStream on: 'S,Supplier1,D,123,bla'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:12'!invalidNewCustomerWithouthSupplierTestData	^ReadStream on: 'NC,Pepe,Sanchez,D,22333444'.! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 17:57'!test04noSePuedeImportarUnCustomerExistenteSinUnSupplier	self		should:			[ self importSuppliersFrom: self invalidExistentCustomerWithouthSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorCannotParseExistentCustomerWithouthSupplier.			self assertSuppliersSize: 0 ]! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 18:14'!test08noSePuedeParsearUnClienteExistenteConMasDeTresCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidExistentCustomerWithFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assert: ( ( system entityIdentifiedAs: '123' ofType: 'D' ) customers size ) equals: 0].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 18:03'!test05noSePuedenParsearTiposInvalidos	self		should:			[ self importSuppliersFrom: self invalidInputTypeAA ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidInputTypeECC ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidInputTypeNCC ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidInputTypeSS ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ]		! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 18:07'!test06noSePuedenParsearInputsDeSuppliersQueNoTenganExactamenteCuatroCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidSupplierWithThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidSupplierWithFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assertSuppliersSize: 0 ].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 17:52'!test03noSePuedeImportarUnNuevoCustomerSinUnSupplier	self		should:			[ self importSuppliersFrom: self invalidNewCustomerWithouthSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorCannotParseNewCustomerWithouthSupplier.			self assertSuppliersSize: 0 ]! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'lm 11/16/2017 20:28'!test01noSePuedeImportarSuppliersDeUnImputVacio	self		should: [ self importSuppliersFrom: ( self emptyInput ) ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorEmptyInputData .			self assertSuppliersSize: 0 ]! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 18:14'!test07noSePuedeParsearUnClienteExistenteConMenosDeTresCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidExistentCustomerWithTwoFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assert: ( ( system entityIdentifiedAs: '123' ofType: 'D' ) customers size ) equals: 0].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/18/2017 17:51'!test02noSePuedeImportarUnaDireccionSinSupplier	self		should:			[ self importSuppliersFrom: self invalidAddressWithouthSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorCannotParseAddressWithouthSupplier.			self assertSuppliersSize: 0 ]! !ErpSystem subclass: #TransientSystem	instanceVariableNames: 'customers entities'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransientSystem methodsFor: 'adding' stamp: 'lm 11/16/2017 20:13'!add: aEntity	entities add: aEntity.! !!TransientSystem methodsFor: 'adding' stamp: 'lm 11/16/2017 20:13'!allEntities	^ entities.! !!TransientSystem methodsFor: 'adding' stamp: 'ad 11/18/2017 16:58'!allEntitiesSize	^ entities size.! !!TransientSystem methodsFor: 'adding' stamp: 'lm 11/16/2017 20:13'!initialize	super initialize.	entities := OrderedCollection new.! !!TransientSystem methodsFor: 'adding' stamp: 'ad 11/18/2017 17:02'!entityIdentifiedAs: anIdNumber ofType: aType		| allEntitiesMatching |	allEntitiesMatching := entities		select: [ :aEntity | 			aEntity isIdentifiedAs: anIdNumber withType: aType  ].			( allEntitiesMatching size ) ~= 1 ifTrue: [ self error: 'Hay más de una instancia del mismo customer' ].		^ allEntitiesMatching anyOne.! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 18 November 2017 at 6:15:43.791936 pm'!!String methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 18 November 2017 at 6:15:43.792492 pm'!!Object methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !