Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'AD 11/12/2017 16:27'!hasStreetName: aStreetName	^ streetName = aStreetName.! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !TestCase subclass: #CustomerImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!TestCase subclass: #CustomerImporterTest	instanceVariableNames: 'customerImporter system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImporterTest methodsFor: 'tearDown' stamp: 'ad 11/20/2017 13:04'!tearDown	system commit.	system close! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'AD 11/12/2017 16:17'!assertValidCustomer: aCustomer withFirstName: aFirstName withLastName: aLastName withIdentificationNumber: anIDNumber withIdentificationType: aType	self assert: aCustomer firstName = aFirstName.	self assert: aCustomer lastName = aLastName.	self assert: aCustomer identificationNumber = anIDNumber.	self assert: aCustomer identificationType = aType.! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 13:05'!assertCustomersSize: aSize	self assert: system allEntitiesSize = aSize! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'ad 11/18/2017 17:05'!assertJuanPerezImportedCorrectly	| customerJuanPerez |		customerJuanPerez := self entityIdentifiedAs: '23-25666777-9' ofType: 'C'.		self 		assertValidCustomer: customerJuanPerez		withFirstName: 'Juan'		withLastName: 'Perez'		withIdentificationNumber: '23-25666777-9'		withIdentificationType: 'C'.			self		assertValidAddress: ( customerJuanPerez addressWithStreetName: 'Alem' )		withStreetNumber: 1122		withStreetName: 'Alem'		withProvince: 'CABA'		withTown: 'CABA'		withZipCode: 1001.! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'ad 11/18/2017 17:05'!assertPepeSanchezImportedCorrectly	| customerPepeSanchez |	customerPepeSanchez := self entityIdentifiedAs: '22333444' ofType: 'D'.		self		assertValidCustomer: customerPepeSanchez		withFirstName: 'Pepe'		withLastName: 'Sanchez'		withIdentificationNumber: '22333444'		withIdentificationType: 'D'.			self		assertValidAddress: ( customerPepeSanchez addressWithStreetName: 'San Martin' )		withStreetNumber: 3322		withStreetName: 'San Martin'		withProvince: 'BsAs'		withTown: 'Olivos'		withZipCode: 1636.			self		assertValidAddress: ( customerPepeSanchez addressWithStreetName: 'Maipu' )		withStreetNumber: 888		withStreetName: 'Maipu'		withProvince: 'Buenos Aires'		withTown: 'Florida'		withZipCode: 1122.! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 13:05'!assertCustomersAddressesSize: aSize	self assert: system allEntitiesAddressesSize = aSize! !!CustomerImporterTest methodsFor: 'asserting' stamp: 'AD 11/12/2017 16:16'!assertValidAddress: anAddress withStreetNumber: aStreetNumber withStreetName: aStreetName withProvince: aProvince withTown: aTown withZipCode: aZipCode	self assert: anAddress streetNumber = aStreetNumber.	self assert: anAddress streetName = aStreetName.	self assert: anAddress province = aProvince.	self assert: anAddress town = aTown.	self assert: anAddress zipCode = aZipCode! !!CustomerImporterTest methodsFor: 'initialization' stamp: 'ad 11/20/2017 13:04'!setUp	system := Environment currentCustomerSystem.	system start.	system beginTransaction.	customerImporter := CustomerImporter with: system! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 12:24'!test06noSePuedenParsearInputsDeDireccionesQueTenganMasDeSeisCamposDeEntrada	self		should:			[ self importFrom: self invalidCustomerWithSevenFieldsAddressTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidAddress.			self assertCustomersAddressesSize: 0 ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 12:24'!test07sePuedenImportarCustomersCorrectos	self importFrom: self validTestData.	self assertCustomersSize: 2.	self assertPepeSanchezImportedCorrectly.	self assertJuanPerezImportedCorrectly! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 12:24'!test05noSePuedenParsearInputsDeDireccionesQueTenganMenosDeSeisCamposDeEntrada	self		should:			[ self importFrom: self invalidCustomerWithFiveFieldsAddressTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidAddress.			self assertCustomersAddressesSize: 0 ].! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 12:24'!test03noSePuedenParsearTiposQueNoSeanClientesNiDirecciones	self		should:			[ self importFrom: self invalidInputType1TestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidTypeOfInput.			self assertCustomersSize: 0 ].	self		should:			[ self importFrom: self invalidInputType2TestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidTypeOfInput.			self assertCustomersSize: 0 ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 12:24'!test04noSePuedenParsearInputsDeClientesQueNoTenganExactamenteCincoCamposDeEntrada	self		should: [ self				importFrom: self invalidCustomerWithThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidCustomer.			self assertCustomersSize: 0 ].	self		should:			[ self importFrom: self invalidCustomerWithSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter errorInvalidCustomer.			self assertCustomersSize: 0]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 12:50'!test01importarDeUnInputVacioGeneraUnaExcepcion	self		should: [ self importFrom: self emptyInput ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: ErpImporter errorEmptyInputData.			self assertCustomersSize: 0 ]! !!CustomerImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 12:51'!test02noSePuedeImportarUnaDireccionSinUnCliente	self		should:			[ self importFrom: self invalidAddressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: ErpImporter  errorCannotParseAddressWithouthEntity.			self assertCustomersSize: 0 ]! !!CustomerImporterTest methodsFor: 'importing' stamp: 'ad 11/20/2017 13:05'!importFrom: input	customerImporter importCustomerFrom: input! !!CustomerImporterTest methodsFor: 'importing' stamp: 'lm 11/16/2017 20:03'!entityIdentifiedAs: anIdNumber ofType: aType	^ system entityIdentifiedAs: anIdNumber ofType: aType! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 16:59'!invalidInputType1TestData	^ ReadStream on: 'CC,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithFiveFieldsAddressTestData	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 16:48'!emptyInput	^ ReadStream on: ''! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithSevenFieldsAddressTestData	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAs, Blabla'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'lm 11/16/2017 19:02'!importSuppliersFrom: InputStream	self error: SuppliersImporter emptyInput .! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithThreeFieldsTestData	^ ReadStream on: 'C,Pepe,Sanchez'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 16:59'!invalidInputType2TestData	^ ReadStream on: 'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidCustomerWithSixFieldsTestData	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444,Blablabla'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'lm 11/9/2017 20:30'!validTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImporterTest methodsFor: 'test data' stamp: 'AD 11/12/2017 17:00'!invalidAddressWithoutCustomerTestData	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'accessing' stamp: 'ad 11/19/2017 08:54'!currentSupplierSystem	( Environment subclasses )		detect: [ :anEnvironment | anEnvironment isCurrent ]		ifFound:  [ :currentEnvironment | ^currentEnvironment supplierSystem ]! !!Environment class methodsFor: 'accessing' stamp: 'lm 11/13/2017 21:31'!isCurrent	self subclassResponsibility.! !!Environment class methodsFor: 'accessing' stamp: 'ad 11/19/2017 08:53'!currentCustomerSystem	( Environment subclasses )		detect: [ :anEnvironment | anEnvironment isCurrent ]		ifFound:  [ :currentEnvironment | ^currentEnvironment customerSystem ]! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'ad 11/19/2017 08:52'!customerSystem	^ TransientSystem new.! !!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'ad 11/19/2017 08:52'!supplierSystem	^ TransientSystem new.! !!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'lm 11/13/2017 21:31'!isCurrent	^ ( IntegrationEnvironment isCurrent ) not.! !Object subclass: #ErpImporter	instanceVariableNames: 'line input record customerImporter supplierImporter'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpImporter methodsFor: 'initialization' stamp: 'ad 11/20/2017 12:28'!isNewCustomerRecord	^ (record at: 1) = 'NC'.! !!ErpImporter methodsFor: 'initialization' stamp: 'ad 11/20/2017 12:25'!isSupplierRecord	^ (record at: 1) = 'S'.! !!ErpImporter methodsFor: 'initialization' stamp: 'ad 11/20/2017 12:28'!isExistentCustomerRecord	^ (record at: 1) = 'EC'.! !!ErpImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 12:27'!isAddressRecord	^ (record at: 1) = 'A'.! !!ErpImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 10:01'!createRecordFromLine	record := line substrings: {$,}! !!ErpImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 12:25'!isCustomerRecord	^ (record at: 1) = 'C'.! !!ErpImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 10:05'!recordSizeEquals: aSize	^ record size = aSize! !!ErpImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 11:29'!importCustomerFrom: inputStream	customerImporter importCustomerFrom: inputStream.! !!ErpImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 13:06'!importSuppliersFrom: inputStream	supplierImporter  importSupplierFrom: inputStream.! !!ErpImporter methodsFor: 'accessing' stamp: 'ad 11/22/2017 14:41'!withCustomerSystem: aCustomerSystem withSupplierSystem: aSupplierSystem	customerImporter := CustomerImporter with: aCustomerSystem.	supplierImporter := SupplierImporter withSystem: aSupplierSystem withCustomerSystem: aCustomerSystem.! !!ErpImporter methodsFor: 'testing' stamp: 'ad 11/20/2017 10:01'!hasNextLine	line := input nextLine.	^ line notNil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ErpImporter class	instanceVariableNames: ''!!ErpImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/20/2017 10:02'!errorEmptyInputData	^ 'El input de entrada es vacio.'! !!ErpImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/20/2017 12:32'!errorInvalidTypeOfInput	^ 'El tipo del input es invalido.'! !!ErpImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/20/2017 12:30'!errorCannotParseAddressWithouthEntity	^ 'No se puede parsear una direccion sin un cliente'! !!ErpImporter class methodsFor: 'accessing' stamp: 'ad 11/20/2017 10:11'!withCustomerSystem: aCustomerSystem withSupplierSystem: aSupplierSystem	^ self new withCustomerSystem: aCustomerSystem withSupplierSystem: aSupplierSystem.! !ErpImporter subclass: #CustomerImporter	instanceVariableNames: 'newCustomer system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 13:02'!parseData	self isCustomerRecord		ifTrue: [ ^ self parseCustomer ].   self isAddressRecord		ifTrue: [ ^ self parseAddress ].			self error: CustomerImporter errorInvalidTypeOfInput.! !!CustomerImporter methodsFor: 'accessing' stamp: 'ad 11/22/2017 14:32'!parseCustomer	(self recordSizeEquals: 5)		ifFalse: [ ^ self error: CustomerImporter errorInvalidCustomer ].	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	system add: newCustomer.! !!CustomerImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 13:01'!importCustomerFrom: inputStream	( inputStream isEmpty ) ifTrue: [ ^ self error: CustomerImporter errorEmptyInputData ].	input := inputStream.	[ self hasNextLine ]		whileTrue: [ 			self createRecordFromLine.			self parseData 			].! !!CustomerImporter methodsFor: 'accessing' stamp: 'lm 11/13/2017 20:49'!with: aSystem		system := aSystem ! !!CustomerImporter methodsFor: 'accessing' stamp: 'ad 11/22/2017 14:35'!allCustomers	^ system allCustomers.! !!CustomerImporter methodsFor: 'accessing' stamp: 'ad 11/20/2017 12:30'!parseAddress	| newAddress |	(self recordSizeEquals: 6)		ifFalse: [ ^ self error: CustomerImporter errorInvalidAddress ].	( newCustomer isNil )		ifTrue: [ ^ self				error: CustomerImporter errorCannotParseAddressWithouthEntity ].	newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newCustomer addAddress: newAddress! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'lm 11/9/2017 20:18'!with: aSession		^ self new with: aSession.! !!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/9/2017 21:04'!errorInvalidAddress	^ 'El input del address es invalido'! !!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/9/2017 20:58'!errorInvalidCustomer	^ 'El input del customer es invalido'! !!CustomerImporter class methodsFor: 'accessing' stamp: 'ad 11/20/2017 12:43'!errorInvalidTypeOfInput	^ 'El tipo del input es invalido.'! !Object subclass: #ErpSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpSystem methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:07'!allEntities
	self subclassResponsibility! !!ErpSystem methodsFor: 'asserting' stamp: 'ad 11/20/2017 13:26'!allCustomers
	^ self allEntities select: [ :aEntity | aEntity isKindOf: Customer ].! !!ErpSystem methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:49'!allSuppliersCustomers	^ ( self allEntities select: [ :aEntity | aEntity isKindOf: Supplier ] ) flatCollect: [ :aEntity | aEntity customers ].! !!ErpSystem methodsFor: 'asserting' stamp: 'ad 11/20/2017 13:31'!allSuppliers
	^ self allEntities select: [ :aEntity | aEntity isKindOf: Supplier ].! !!ErpSystem methodsFor: 'asserting' stamp: 'ad 11/18/2017 16:52'!entityIdentifiedAs: anIdNumber ofType: aType
	self subclassResponsibility! !!ErpSystem methodsFor: 'accessing' stamp: 'lm 11/13/2017 20:57'!add: newCustomer
	self subclassResponsibility! !!ErpSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 13:31'!allSuppliersSize	^ ( self allSuppliers ) size.! !!ErpSystem methodsFor: 'initialization' stamp: 'lm 11/13/2017 21:08'!beginTransaction! !!ErpSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:09'!allEntitiesSize	^ ( self allEntities ) size.! !!ErpSystem methodsFor: 'initialization' stamp: 'lm 11/13/2017 21:08'!start! !!ErpSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:19'!allEntitiesAddressesSize	 ^ ( self allEntities flatCollect: [ :aEntity | aEntity addresses ] ) size.! !!ErpSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:50'!allSuppliersCustomersSize	 ^ self allSuppliersCustomers size .! !!ErpSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 13:31'!allCustomersSize	^ ( self allCustomers ) size.! !!ErpSystem methodsFor: 'tearDown' stamp: 'lm 11/13/2017 21:08'!close! !!ErpSystem methodsFor: 'tearDown' stamp: 'lm 11/13/2017 21:08'!commit! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'ad 11/19/2017 08:52'!customerSystem	^ PersistentCustomerSystem new.! !!IntegrationEnvironment class methodsFor: 'testing' stamp: 'ad 11/19/2017 08:52'!supplierSystem	^ PersistentSupplierSystem new.! !!IntegrationEnvironment class methodsFor: 'testing' stamp: 'ad 11/22/2017 14:44'!isCurrent	^true.! !Object subclass: #Party	instanceVariableNames: 'id identificationNumber identificationType addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Party methodsFor: 'addresses' stamp: 'ad 11/19/2017 08:50'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'addresses' stamp: 'ad 11/19/2017 08:50'!addresses	^ addresses! !!Party methodsFor: 'addresses' stamp: 'ad 11/19/2017 08:50'!addressWithStreetName: aStreetName	^  self addresses		detect: [ :anAddress | anAddress hasStreetName: aStreetName  ].! !!Party methodsFor: 'addresses' stamp: 'ad 11/19/2017 08:49'!isIdentifiedAs: anIDNumber withType: anIDType	^ identificationNumber = anIDNumber and: [ identificationType = anIDType  ].! !!Party methodsFor: 'initialization' stamp: 'ad 11/19/2017 08:50'!initialize	super initialize.	addresses := OrderedCollection new.! !!Party methodsFor: 'identification' stamp: 'ad 11/19/2017 08:49'!id: anID	super id: anID.! !!Party methodsFor: 'identification' stamp: 'ad 11/19/2017 08:49'!id	^ super id.! !!Party methodsFor: 'identification' stamp: 'ad 11/19/2017 08:49'!identificationNumber		^identificationNumber ! !!Party methodsFor: 'identification' stamp: 'ad 11/19/2017 08:49'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Party methodsFor: 'identification' stamp: 'ad 11/19/2017 08:49'!identificationType		^identificationType ! !!Party methodsFor: 'identification' stamp: 'ad 11/19/2017 08:49'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName customerId'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: 'test'!ErpSystem subclass: #PersistentSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentSystem methodsFor: 'tearDown' stamp: 'ad 11/20/2017 11:06'!close	session close.! !!PersistentSystem methodsFor: 'tearDown' stamp: 'ad 11/20/2017 11:07'!commit	session commit.! !!PersistentSystem methodsFor: 'accessing' stamp: 'ad 11/20/2017 11:41'!add: aEntity	session persist: aEntity.! !!PersistentSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:07'!beginTransaction	session beginTransaction! !!PersistentSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:11'!start	session open.! !!PersistentSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:07'!initialize	super initialize.	"customerSystem := PersistentCustomerSystem new.	supplierSystem := PersistentSupplierSystem new."! !PersistentSystem subclass: #PersistentCustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentCustomerSystem methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:05'!allEntities	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'asserting' stamp: 'ad 11/20/2017 10:26'!allCustomers	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:05'!initialize	super initialize.	session := (DataBaseSession for: (Array with: self mapCustomers with: self mapAddress ))! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'ad 11/17/2017 19:29'!mapCustomers	^(ClassMapping						withDefaultTableNameFor: Customer						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #firstName)								with: (EmbededMapping withDefaultFieldNameFor: #lastName)								with: (EmbededMapping withDefaultFieldNameFor: #identificationType)								with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)								with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))).! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 19:32'!mapAddress	^ (ClassMapping						withDefaultTableNameFor: Address						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #streetName)								with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)								with: (EmbededMapping withDefaultFieldNameFor: #town)								with: (EmbededMapping withDefaultFieldNameFor: #zipCode)								with: (EmbededMapping withDefaultFieldNameFor: #province)))! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:06'!entityIdentifiedAs: anIdNumber ofType: aType	|entities|	entities := session		select: [ :aParty | aParty isIdentifiedAs: anIdNumber withType: aType ]		ofType: Customer.			( entities size ) ~= 1 ifTrue: [ self error: 'Hay más de una instancia del mismo supplier' ].		^ entities anyOne.! !PersistentSystem subclass: #PersistentSupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentSupplierSystem methodsFor: 'importing' stamp: 'ad 11/20/2017 11:06'!entityIdentifiedAs: anIdNumber ofType: aType	|entities|	entities := session		select: [ :aParty | aParty isIdentifiedAs: anIdNumber withType: aType ]		ofType: Supplier.			( entities size ) ~= 1 ifTrue: [ self error: 'Hay más de una instancia del mismo supplier' ].		^ entities anyOne.! !!PersistentSupplierSystem methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:06'!allEntities	^ session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:47'!mapCustomers	^(ClassMapping						withDefaultTableNameFor: Customer						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #firstName)								with: (EmbededMapping withDefaultFieldNameFor: #lastName)								with: (EmbededMapping withDefaultFieldNameFor: #identificationType)								with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)								with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))).! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:47'!mapAddress	^ (ClassMapping						withDefaultTableNameFor: Address						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #streetName)								with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)								with: (EmbededMapping withDefaultFieldNameFor: #town)								with: (EmbededMapping withDefaultFieldNameFor: #zipCode)								with: (EmbededMapping withDefaultFieldNameFor: #province)))! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'lm 11/16/2017 20:48'!mapSuppliers	^ (ClassMapping						withDefaultTableNameFor: Supplier						mappingAll:							(Array								with: (EmbededMapping withDefaultFieldNameFor: #name)								with: (EmbededMapping withDefaultFieldNameFor: #identificationType)								with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)								with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)								with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)								))"Formato de importacion de Supplier:S,Supplier1,D,123 NC,Pepe,Sanchez,D,22333444 <-- new customerEC,D,5456774                            <-- existing customerA,San Martin,3322,Olivos,1636,BsAs A,Maipu,888,Florida,1122,Buenos Aires"! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'ad 11/20/2017 11:06'!initialize	super initialize.	session := (DataBaseSession for: (Array with: self mapSuppliers with: self mapAddress with: self mapCustomers )).! !Party subclass: #Supplier	instanceVariableNames: 'name customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 20:42'!customers	^customers.! !!Supplier methodsFor: 'accessing' stamp: 'ad 11/22/2017 14:51'!customerWithIdentificationNumber: anIdNumber withIdentificationType: aIdType		^ self customers		detect: [ :aCustomer |  aCustomer isIdentifiedAs: anIdNumber  withType: aIdType ].! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 19:40'!name: aName	name := aName.! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 19:40'!name		^name.! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 20:41'!addCustomer: aCustomer	customers add: aCustomer.! !!Supplier methodsFor: 'accessing' stamp: 'lm 11/16/2017 19:46'!initialize	super initialize.	customers := OrderedCollection new.! !ErpImporter subclass: #SupplierImporter	instanceVariableNames: 'newSupplier system customerSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/18/2017 18:06'!parseSupplier	(self recordSizeEquals: 4)		ifFalse: [ ^ self error: SupplierImporter errorInvalidSupplier ].	newSupplier := Supplier new.	newSupplier name: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.		system add: newSupplier.! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/22/2017 14:41'!parseExistentCustomer	| customers identificationType identificationNumber |	(self recordSizeEquals: 3)		ifFalse: [ ^ self error: SupplierImporter errorInvalidSupplier ].	( newSupplier isNil ) ifTrue: [ ^ self error: SupplierImporter errorCannotParseExistentCustomerWithouthSupplier  ].				identificationType := record second.	identificationNumber := record third.			customers := customerSystem allCustomers.	customers select: [ :aCustomer | aCustomer isIdentifiedAs: identificationNumber  withType: identificationType  ].		( customers size = 0 ) ifTrue: [ ^ self error: SupplierImporter errorNonExistentCustomer ].		newSupplier addCustomer: (customers anyOne).! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/20/2017 13:03'!parseAddress	| newAddress |	(self recordSizeEquals: 6)		ifFalse: [ ^ self error: SupplierImporter errorInvalidAddress ].	( newSupplier isNil ) ifTrue: [ ^ self error: ErpImporter errorCannotParseAddressWithouthEntity ].	newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newSupplier addAddress: newAddress! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/22/2017 14:42'!parseNewCustomer	| newCustomer |	(self recordSizeEquals: 5)		ifFalse: [ ^ self error: SupplierImporter errorInvalidSupplier ].	( newSupplier isNil ) ifTrue: [ ^ self error: SupplierImporter errorCannotParseNewCustomerWithouthSupplier  ].	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	customerSystem add: newCustomer.	newSupplier addCustomer: newCustomer.! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/20/2017 13:01'!parseData	self isSupplierRecord  		ifTrue: [ ^ self parseSupplier ].	self isNewCustomerRecord 		ifTrue: [ ^ self parseNewCustomer ].	self isExistentCustomerRecord 		ifTrue: [ ^ self parseExistentCustomer ].   self isAddressRecord		ifTrue: [ ^ self parseAddress ].			self error: SupplierImporter errorInvalidTypeOfInput.! !!SupplierImporter methodsFor: 'parsing' stamp: 'ad 11/20/2017 13:01'!importSupplierFrom: inputStream	( inputStream isEmpty ) ifTrue: [ ^ self error: SupplierImporter errorEmptyInputData ].	input := inputStream.	[ self hasNextLine ]		whileTrue: [ 			self createRecordFromLine.			self parseData 			].! !!SupplierImporter methodsFor: 'initialization' stamp: 'ad 11/22/2017 14:41'!withSystem: aSystem withCustomerSystem: aCustomerSystem		system := aSystem.	customerSystem := aCustomerSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'ad 11/22/2017 14:42'!withSystem: aSession withCustomerSystem: aCustomerSystem		^ self new withSystem: aSession withCustomerSystem: aCustomerSystem.! !!SupplierImporter class methodsFor: 'accessing' stamp: 'ad 11/20/2017 12:43'!errorInvalidTypeOfInput	^ 'El tipo del input es invalido.'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/20/2017 13:04'!errorCannotParseExistentCustomerWithouthSupplier	^ 'No se puede agregar un cliente ya existente sin un supplier'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/18/2017 17:54'!errorInvalidSupplier	^ 'El input del supplier es invalido'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'lm 11/16/2017 19:17'!errorInvalidAddress	^ 'El input del address es invalido'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/20/2017 11:32'!errorNonExistentCustomer	^ 'El customer no existe en el sistema'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'ad 11/20/2017 13:04'!errorCannotParseNewCustomerWithouthSupplier	^ 'No se puede parsear un nuevo cliente sin un supplier'! !TestCase subclass: #SuppliersImporterTest	instanceVariableNames: 'supplierSystem customerSystem importer system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SuppliersImporterTest methodsFor: 'setUp-tearDown' stamp: 'ad 11/22/2017 14:32'!setUp	supplierSystem := Environment currentSupplierSystem.	supplierSystem start.	supplierSystem beginTransaction.	customerSystem := Environment currentCustomerSystem.	customerSystem start.	customerSystem beginTransaction.	importer := ErpImporter withCustomerSystem: customerSystem withSupplierSystem: supplierSystem.! !!SuppliersImporterTest methodsFor: 'setUp-tearDown' stamp: 'ad 11/22/2017 14:24'!tearDown	supplierSystem commit.	supplierSystem close.	customerSystem commit.	customerSystem close! !!SuppliersImporterTest methodsFor: 'importing' stamp: 'ad 11/20/2017 13:08'!importCustomerFrom: input		^ importer importCustomerFrom: input				! !!SuppliersImporterTest methodsFor: 'importing' stamp: 'ad 11/20/2017 13:06'!importSuppliersFrom: inputStream	^ importer importSuppliersFrom: inputStream.				! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:56'!assertValidAddress: anAddress withStreetNumber: aStreetNumber withStreetName: aStreetName withProvince: aProvince withTown: aTown withZipCode: aZipCode	self assert: anAddress streetNumber = aStreetNumber.	self assert: anAddress streetName = aStreetName.	self assert: anAddress province = aProvince.	self assert: anAddress town = aTown.	self assert: anAddress zipCode = aZipCode! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/22/2017 14:50'!assertSupplier1ImportedCorrectly	| supplier1 |		supplier1 := supplierSystem entityIdentifiedAs: '123' ofType: 'D'.		self		assertValidSupplier: supplier1 withName: 'Supplier1'  withIdentificationNumber: '123' withIdentificationType: 'D'.			self		assertValidAddress: ( supplier1 addressWithStreetName: 'Maipu' )		withStreetNumber: 888		withStreetName: 'Maipu'		withProvince: 'Buenos Aires'		withTown: 'Florida'		withZipCode: 1122.	self		assertValidAddress: ( supplier1 addressWithStreetName: 'San Martin' )		withStreetNumber: 3322		withStreetName: 'San Martin'		withProvince: 'BsAs'		withTown: 'Olivos'		withZipCode: 1636.		self		assertValidCustomer: ( supplier1 customerWithIdentificationNumber: '23-25666777-9' withIdentificationType: 'C' )		withFirstName: 'Juan'		withLastName: 'Perez' 		withIdentificationNumber: '23-25666777-9'  		withIdentificationType: 'C'.			self		assertValidCustomer: ( supplier1 customerWithIdentificationNumber: '22333444' withIdentificationType: 'D' )		withFirstName: 'Pepe'		withLastName: 'Sanchez' 		withIdentificationNumber: '22333444'  		withIdentificationType: 'D'.! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:27'!assertSuppliersCustomerSize: aSize	self assert: ( supplierSystem allSuppliersCustomersSize = aSize )! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 13:32'!assertSuppliersSize: aSize	self assert: supplierSystem allSuppliersSize = aSize! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 13:35'!assertSupplier2ImportedCorrectly	| supplier1 |		supplier1 := supplierSystem entityIdentifiedAs: '456' ofType: 'D'.		self		assertValidSupplier: supplier1 withName: 'Supplier2'  withIdentificationNumber: '456' withIdentificationType: 'D'.		self		assertValidCustomer: ( supplier1 customerWithIdentificationNumber: '123456' withIdentificationType: 'D' )		withFirstName: 'Juanito'		withLastName: 'Nieve' 		withIdentificationNumber: '123456'  		withIdentificationType: 'D'.			self		assertValidAddress: ( supplier1 addressWithStreetName: 'Santa Fe' )		withStreetNumber: 2900		withStreetName: 'Santa Fe'		withProvince: 'BsAs'		withTown: 'CABA'		withZipCode: 1425.! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/22/2017 14:26'!assertCustomersSize: aSize	self assert: customerSystem allCustomersSize = aSize! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:56'!assertValidSupplier: aSupplier withName: aName withIdentificationNumber: anIDNumber withIdentificationType: aType	self assert: aSupplier name  = aName.	self assert: aSupplier identificationNumber = anIDNumber.	self assert: aSupplier identificationType = aType.! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:56'!assertValidCustomer: aCustomer withFirstName: aFirstName withLastName: aLastName withIdentificationNumber: anIDNumber withIdentificationType: aType	self assert: aCustomer firstName = aFirstName.	self assert: aCustomer lastName = aLastName.	self assert: aCustomer identificationNumber = anIDNumber.	self assert: aCustomer identificationType = aType.! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:55'!assertJuanPerezImportedCorrectly	| customerJuanPerez |		customerJuanPerez := customerSystem entityIdentifiedAs: '23-25666777-9' ofType: 'C'.		self 		assertValidCustomer: customerJuanPerez		withFirstName: 'Juan'		withLastName: 'Perez'		withIdentificationNumber: '23-25666777-9'		withIdentificationType: 'C'.			self		assertValidAddress: ( customerJuanPerez addressWithStreetName: 'Alem' )		withStreetNumber: 1122		withStreetName: 'Alem'		withProvince: 'CABA'		withTown: 'CABA'		withZipCode: 1001.! !!SuppliersImporterTest methodsFor: 'asserting' stamp: 'ad 11/20/2017 11:27'!assertSuppliersAddressesSize: aSize	self assert: ( supplierSystem allEntitiesAddressesSize = aSize )! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/20/2017 13:07'!validSupplierTestData	^ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444EC,C,23-25666777-9A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresS,Supplier2,D,456NC,Juanito,Nieve,D,123456,A,Santa Fe,2900,CABA,1425,BsAs'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:06'!invalidSupplierWithThreeFieldsTestData	^ReadStream on: 'S,Supplier1,D'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeSS	^ReadStream on: 'SS,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 17:56'!invalidExistentCustomerWithouthSupplierTestData	^ReadStream on: 'EC,D,5456774'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeECC	^ReadStream on: 'ECC,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/19/2017 09:02'!invalidAddressWithSevenFieldsTestData	^ReadStream on: 'S,Supplier1,D,123A,San Martin,3322,Olivos,1636,BsAs,bla'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:13'!invalidExistentCustomerWithTwoFieldsTestData	^ReadStream on: 'S,Supplier1,D,123EC,D'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:12'!invalidExistentCustomerWithFourFieldsTestData	^ReadStream on: 'S,Supplier1,D,123EC,D,123,bla'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 17:12'!invalidAddressWithouthSupplierTestData	^ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeAA	^ReadStream on: 'AA,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'lm 11/16/2017 19:08'!emptyInput	^ ReadStream on: ''! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/19/2017 09:02'!invalidAddressWithFiveFieldsTestData	^ReadStream on: 'S,Supplier1,D,123A,San Martin,3322,Olivos,1636'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:02'!invalidInputTypeNCC	^ReadStream on: 'NCC,Supplier1,D,123 '.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:07'!invalidSupplierWithFiveFieldsTestData	^ReadStream on: 'S,Supplier1,D,123,bla'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/18/2017 18:12'!invalidNewCustomerWithouthSupplierTestData	^ReadStream on: 'NC,Pepe,Sanchez,D,22333444'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/20/2017 13:07'!validCustomerTestData	^ReadStream on: 'C,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'.! !!SuppliersImporterTest methodsFor: 'testData' stamp: 'ad 11/20/2017 11:32'!invalidNonExistentCustomer	^ReadStream on: 'S,Supplier1,D,123EC,D,22333444'.! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test04noSePuedeImportarUnCustomerExistenteSinUnSupplier	self		should:			[ self importSuppliersFrom: self invalidExistentCustomerWithouthSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorCannotParseExistentCustomerWithouthSupplier.			self assertSuppliersSize: 0 ]! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test08noSePuedeParsearUnClienteExistenteConMasDeTresCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidExistentCustomerWithFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assertSuppliersCustomerSize: 0].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:34'!test12sePuedenImportarSuppliers	self importCustomerFrom: self validCustomerTestData.	self assertCustomersSize: 1.	self assertJuanPerezImportedCorrectly.	self importSuppliersFrom: self validSupplierTestData.	self assertSuppliersSize: 2.	self assertSupplier1ImportedCorrectly.	self assertSupplier2ImportedCorrectly.! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:07'!test05noSePuedenParsearTiposInvalidos	self		should:			[ self importSuppliersFrom: self invalidInputTypeAA ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidInputTypeECC ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidInputTypeNCC ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidInputTypeSS ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidTypeOfInput.			self assertSuppliersSize: 0 ]		! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test06noSePuedenParsearInputsDeSuppliersQueNoTenganExactamenteCuatroCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidSupplierWithThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assertSuppliersSize: 0 ].	self		should:			[ self importSuppliersFrom: self invalidSupplierWithFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assertSuppliersSize: 0 ].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test03noSePuedeImportarUnNuevoCustomerSinUnSupplier	self		should:			[ self importSuppliersFrom: self invalidNewCustomerWithouthSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorCannotParseNewCustomerWithouthSupplier.			self assertSuppliersSize: 0 ]! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test11noSePuedeParsearUnCustomerNoExistenteComoCustomerExistente	self		should:			[ self importSuppliersFrom: self invalidNonExistentCustomer ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self assert: error messageText equals: SupplierImporter errorNonExistentCustomer.			self assertSuppliersCustomerSize: 0].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test01noSePuedeImportarSuppliersDeUnImputVacio	self		should: [ self importSuppliersFrom: ( self emptyInput ) ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorEmptyInputData .			self assertSuppliersSize: 0 ]! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test07noSePuedeParsearUnClienteExistenteConMenosDeTresCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidExistentCustomerWithTwoFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: SupplierImporter errorInvalidSupplier.			self assertSuppliersCustomerSize: 0 ].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test10noSePuedenParsearInputsDeDireccionesQueTenganMasDeSeisCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidAddressWithSevenFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self assert: error messageText equals: SupplierImporter errorInvalidAddress .			self assertSuppliersAddressesSize: 0].! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test02noSePuedeImportarUnaDireccionSinSupplier	self		should:			[ self importSuppliersFrom: self invalidAddressWithouthSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: ErpImporter errorCannotParseAddressWithouthEntity.			self assertSuppliersSize: 0 ]! !!SuppliersImporterTest methodsFor: 'tests' stamp: 'ad 11/20/2017 13:06'!test09noSePuedenParsearInputsDeDireccionesQueTenganMenosDeSeisCamposDeEntrada	self		should:			[ self importSuppliersFrom: self invalidAddressWithFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self assert: error messageText equals: SupplierImporter errorInvalidAddress .			self assertSuppliersAddressesSize: 0 ].! !ErpSystem subclass: #TransientSystem	instanceVariableNames: 'customers entities suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransientSystem methodsFor: 'adding' stamp: 'lm 11/16/2017 20:13'!allEntities	^ entities.! !!TransientSystem methodsFor: 'adding' stamp: 'ad 11/22/2017 14:32'!add: aEntity	entities add: aEntity.! !!TransientSystem methodsFor: 'adding' stamp: 'ad 11/20/2017 10:36'!allCustomers	^ entities select: [ :aEntity | aEntity isKindOf: Customer ].! !!TransientSystem methodsFor: 'adding' stamp: 'ad 11/20/2017 10:36'!allSuppliers	^ entities select: [ :aEntity | aEntity isKindOf: Supplier ].! !!TransientSystem methodsFor: 'adding' stamp: 'ad 11/20/2017 10:35'!initialize	super initialize.	entities := OrderedCollection new.! !!TransientSystem methodsFor: 'adding' stamp: 'ad 11/18/2017 17:02'!entityIdentifiedAs: anIdNumber ofType: aType		| allEntitiesMatching |	allEntitiesMatching := entities		select: [ :aEntity | 			aEntity isIdentifiedAs: anIdNumber withType: aType  ].			( allEntitiesMatching size ) ~= 1 ifTrue: [ self error: 'Hay más de una instancia del mismo customer' ].		^ allEntitiesMatching anyOne.! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'ad 11/19/2017 08:47'!assertHasIdInstanceVariable: aClass 		(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'ad 11/19/2017 08:48'!assertIsValidFor: aClass 		(aClass classThatDefinesInstanceVariable: instanceVariableName) ifNil: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 22 November 2017 at 2:51:36.094298 pm'!!String methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60520] on 22 November 2017 at 2:51:36.096693 pm'!!Object methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !